include::../../config.adoc[]
= IDL
////
Copyright (c) 2016 NumberFour AG.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
  NumberFour AG - Initial API and implementation
////

== IDL Support

task:IDE-2391[]
task:IDE-2394[]
task:IDE-2396[]
task:IDE-2370[]
task:IDE-2395[]

.Versioned Elements
[req,id=IDE-2391-01,version=1]
--
In N4IDL, the following type defining elements can be versioned:

* Classes
* Interfaces
* Enums

No other elements can be versioned. Unversioned elements implicitly have a version of 0.
Multiple versions of the same classifier can be declared in the same module.
--

.Versioned Element Syntax
[req,id=IDE-2391-02,version=1]
--
The syntax for declaring versioned elements is as follows.

```
N4ClassDeclaration <Yield> returns N4IDLClassDeclaration:
	=>(
		{N4IDLClassDeclaration}
		(declaredModifiers+=N4Modifier)*
		'class' name=BindingIdentifier<Yield> VersionDeclaration
	)
	TypeVariables?
	ClassExtendsClause<Yield>?
	Members<Yield>
;
```

Thereby, `VersionDeclaration` is defined as

```
fragment VersionDeclaration*: # declaredVersion=INT;
```
--

.Versioned References
[req,id=IDE-2391-03,version=1]
--
It is possible to request a specific version of a versioned element using explicitly versioned references.

Explicitly versioned references are allowed in the following places.

* to reference a versioned type in the parameter and return type declarations of a migration
* to reference a versioned type in the type declaration of a local variable in the body of a migration
* to reference a versioned instantiable type in a new expression in the body of a migration

Explicitly versioned references not allowed in any other place.
--

.Versioned Reference Syntax
[req,id=IDE-2391-04,version=1]
--
The syntax for explicitly versioned references is as follows.

```
ParameterizedTypeRefNominal returns typerefs::ParameterizedTypeRef:
	declaredType=[types::Type|TypeReferenceName]
	VersionRequest?
	(=> '<' typeArgs+=TypeArgument (',' typeArgs+=TypeArgument)* '>')?
;
```

```
IdentifierRef<Yield> returns n4js::IdentifierRef:
	id=[types::IdentifiableElement|BindingIdentifier<Yield>]
	VersionRequest?
;
```

Thereby, `VersionRequest` is defined as

```
fragment VersionRequest*: # requestedVersion=INT;
```
--

We use this syntax to refer to specific versions of versioned elements in this document. For example, the name `A#2` refers to version 2 of a versioned element `A`.

.Virtual Element Versions
[req,id=IDE-2391-05,version=1]
--
Not every version of a type must be explicitly declared. For example, it is possible to declare `A#1` and `A#3` in a situation where `A#2` would be identical to `A#1`. To avoid duplication, `A#1` represents both versions 1 and 2 of `A`, and we call `A#2` a virtual version of `A`.

It must be possible to refer to virtual versions, either explicitly or implicitly, as if they actually existed. Suppose a reference refers to version n of some element `X`. Then it must be bound to the greatest non-virtual version of `X` that is not greater than n.
--

.Unversioned References
[req,id=IDE-2391-06,version=1]
--
A reference without an explicitly requested version is called an unversioned reference. An unversioned reference is implicitly versioned according to the following rules.

* A `this` literal must refer to the exact version of the type that contains it.
* A parameterized type reference


--

.Migrations
[req,id=IDE-2391-07,version=1]
--
--

.Migration Syntax
[req,id=IDE-2391-08,version=1]
--
```
MigrationDeclaration:
	'migration'
	'(' fpars+=FormalParameter<false> (',' fpars+=FormalParameter<false>)* ')'
	'->'
	'(' frets+=FormalParameter<false> (',' frets+=FormalParameter<false>)* ')'
	FunctionBody<false,false>
;
```
--
