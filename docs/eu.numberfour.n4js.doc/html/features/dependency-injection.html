<!DOCTYPE HTML>
<html>
<head>

  <!-- ************* Meta ************* -->
  <title>Dependency Injection · Features · N4JS Language and IDE</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <!-- eclipse -->


  <!-- ************* Styles ************* -->
  <link rel="stylesheet" type="text/css" href="../styles/eclipse.min.5f975d04.css">

  <!-- ****************** Scripts ****************** -->
  <script type="text/javascript" src="../scripts/scripts-legacy.js"></script>
</head>

<body>
  <header class="Grid"></header>

  <div class="Main">
    <article class="Article--noGrid">

<h1>Dependency Injection in N4JS</h1>

<p class="Introduction">Dependency injection (DI) is a concept that allows for configuring dependencies between classes at a central location. Instead of passing dependencies from class to class, N4JS' built-in DI support does this automatically. This makes the user code much cleaner, easier to maintain and also improves its testability. N4JS DI framework follows Java JSR-330/Google Guice, making its usage easy for Java developers.</p>

<h2>Application Object Graph</h2>

<p>In object oriented languages applications are composed from objects that interact with each other. Instances of those objects need to be created and wired together on application startup to create a so-called object graph of the application. While it's possible to manually create this object graph, it quickly becomes complicated. This is especially so if we want flexibility and reconfigurability to be long-lasting features of our application.</p>

<p>Solutions for wiring the object graph manually come with different disadvantages:</p>

<ul>
  <li>Hard coding dependencies makes code inflexible, in particular hard to test.</li>
  <li>Passing dependencies to constructors bloats the constructors.</li>
  <li>Using factories requires passing the factory and also bloats the code.</li>
</ul>

<h2>Dependency Injection (DI)</h2>

<p>Dependency injection (DI) and DI frameworks aim to help with issues described above.</p>

<ul>
  <li>The object graph is created automatically, which removes burden of writing object factories.</li>
  <li>Injection of the created instances is done behind the scenes where needed, which separates object creation from object usage and keeps constructor simple.</li>
  <li>The application's configuration can be changed without changing its components.</li>
</ul>

<p>N4JS provides built-in support for dependency injection, using a lightweight syntax with annotation similar to Java <a href="https://jcp.org/en/jsr/detail?id=330">JSR-330</a>/<a href="https://github.com/google/guice">Google Guice</a>. The N4JS testing framework also support dependency injection, which allows for special test settings in order to test components separately.</p>

<h2>Example</h2>

<p>In the following example, two versions of a simple weather application are implemented. Both version use a module WeatherEngine which returns the temperature for a given city. For this example, we use a timeout to emulate a real request to a weather server:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">export public class WeatherEngine {
    data = [ {city: 'Berlin', temp: 5}, {city: 'Hamburg', temp: 15}, {city: 'Palo Alto', temp: 10} ];

    public temperature(city: string): Promise&lt;number, ?&gt; {
        return new Promise&lt;number, any&gt;(
            (cb: {function(number)}) =&gt; {
                setTimeout(() =&gt; cb(this.data.find(e =&gt; e.city == city).temp) , Math.random() * 2000);
            });
    }
}
</pre></div>

<p>In order to keep the examples as small as possible, in the non-DI version no manual wiring of the dependencies is used – instead the components are set up by simply initializing fields directly.</p>

<div class="Comparison">
  <div class="Comparison-left">
    <h3>Without Dependency-Injection</h3>
    
<div class="Example"><pre name="code" class="n4js:nocontrols">import { WeatherEngine } from 'WeatherEngine';

export class WeatherApp {
    private engine: WeatherEngine = new WeatherEngine();

    async printTemp(city: string): string {
        return city + ': ' + (await this.engine.temperature(city));
    }
}


export class Server {
    weatherApp: WeatherApp = new WeatherApp();

    async run() {
        for (var s of ['Berlin', 'Hamburg', 'Palo Alto']) {
            console.log(await this.weatherApp.printTemp(s));
        }
    }
}
</pre><div class="Example-caption">WeatherApp.n4js</div></div>

<div class="Example"><pre name="code" class="n4js:nocontrols">import { Server } from 'WeatherApp'


var server = new Server();
server.run();
</pre><div class="Example-caption">Starter.n4js</div></div>

  </div>
  <div class="Comparison-right">
    <h3>With Dependency-Injection</h3>

<div class="Example"><pre name="code" class="n4js:nocontrols">import { WeatherEngine } from 'WeatherEngine';

export class WeatherApp {
    @Inject private engine: WeatherEngine;

    async printTemp(city: string): string {
        return city + ': ' + (await this.engine.temperature(city));
    }
}

@GenerateInjector
export class Server {
    @Inject weatherApp: WeatherApp;

    async run() {
        for (var s of ['Berlin', 'Hamburg', 'Palo Alto']) {
            console.log(await this.weatherApp.printTemp(s));
        }
    }
}
</pre><div class="Example-caption">WeatherAppDI.n4js</div></div>

<div class="Example"><pre name="code" class="n4js:nocontrols">import { Server } from 'WeatherAppDI';
import { N4Injector } from 'n4js/lang/N4Injector';

var server = N4Injector.of(Server).create(Server);
server.run(); 
</pre><div class="Example-caption">StarterDI.n4js</div></div>
    
  </div>
</div>

<p>The changes are only minimal: Instead of creating the field instances directly, they are annotated with <code>@Inject</code> (line 4 and 13). This is familiar for Java programmers having used Google Guice.</p>

<p>An interesting part of dependency injection is how to set up the injector. In N4JS, the annotation <code>@GenerateInjector</code> (line 11) is used in order mark a class as a dependency injection component, that is to associate an injector with the class. Running the server now needs a little bit different instantiation. Instead of constructing the server with <code>new</code>, the built-in class <code>N4Injector</code> is then used to create the first instance (line 4, StarterDI.n4js).</p>


<h2>Application Reconfigurability</h2>

<p>The great thing about DI is its flexibility. This is particularly important for testing. Let's write a test class for our <code>WeatherApp</code>. For the test, we do not want to wait an arbitrary amount of seconds to get the result. Instead, we want to use a special version of the <code>WeatherEngine</code> immediately returning a value. Let's have a look at the full test module:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols">import { WeatherApp } from 'WeatherAppDI';
import { WeatherEngine } from 'WeatherEngine';
import { Assert } from 'n4/mangel/assert/Assert';

class WeatherEngineMock extends WeatherEngine {
    @Override
    public async temperature(city: string): number {
        return 1;
    }
}

@Binder
@Bind(WeatherEngine, WeatherEngineMock)
class WeatherAppTestConfig{ }

@GenerateInjector()
@UseBinder(WeatherAppTestConfig)
export class WeatherAppTest {
    @Inject weatherApp: WeatherApp;

    @Test public async test() {
        Assert.equal(await this.weatherApp.printTemp('Berlin'), 'Berlin: 1');
    }
}
</pre></div>

<p>We have to write the mock (lines 5-10). Then we create a new "binder" (line 12-14), that is a configuration telling the injector what actual type has to be used to instantiate objects. By default, the injector uses the same class as references in the code. We change that, and bind the mock to the real engine.</p>
    <p>The N4JS test framework already supports DI. We can simply declare the test as a new dependency injection component (line 16), using the specific test configuration (line 17). The important point is, that the class <code>WeatherApp</code> now gets the <code>WeatherEngineMock</code> injected!</p>

<h2>Advanced features</h2>

<p>Advantages and DI features are discussed in greater detail in the N4JS language spec. Notable features are:</p>

<ul>
    <li>built-in pseudo-scope via <code>@Singleton</code></li>
    <li>possibility of nesting injectors via <code>@WithParentInjector</code></li>
    <li>built in <code>Provider</code> type and possibility to create custom providers via <code>@Provides</code> to dynamically create instances</li>
    <li>automatic resolution of dependency cycles</li>
</ul>


    </article>


  </div>
  <footer class="Grid"></footer>
  <script>
    dp.SyntaxHighlighter.HighlightAll('code');
  </script>

</body>
</html>
