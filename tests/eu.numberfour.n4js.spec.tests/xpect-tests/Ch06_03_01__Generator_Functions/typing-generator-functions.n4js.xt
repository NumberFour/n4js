/* XPECT_SETUP eu.numberfour.n4js.spec.tests.N4JSSpecTest END_SETUP */


// generator function expression
// XPECT noerrors
let xx = function * () {};
xx;

// generator method
// XPECT noerrors
class M {
	* g0 () {}
}

// generator method in object literal
// XPECT noerrors
let obj = {
	* g0() {}
};
obj;


// no return ok
// XPECT noerrors
function * g1() {
}

// recursive yield type ok
// XPECT noerrors
function * g2() {
	yield * g1();
}

// yield has return
// XPECT noerrors
function * g3a() {
	let x = yield; 
	x;
}

// err
// yield has return of type any, error case
// XPECT errors
function * g3b() {
	let x : string = yield; 
	x;
}

// yield has return
// XPECT noerrors
function * g3c() : Generator<?,?,int> {
	let x = yield; 
	x;
}

// yield has return of type TNext
// XPECT noerrors
function * g4() : Generator<?,?,string>{
	let x : string = yield; 
	x;
}

// err
// yield is only allowed in generators
/* XPECT errors ---
"yield is a reserved identifier." at "yield"
"Couldn't resolve reference to IdentifiableElement 'yield'." at "yield"
--- */
function g5() {
	yield;
}
 
// yield can provide a return expression
// XPECT noerrors
function * g6() {
	yield 1 + 2;
}

// yield can provide a return expression using the shorthand form
// XPECT noerrors
function * g7() : int {
	yield 1 + 2;
}

// yield can provide a return expression using the explicit form
// XPECT noerrors
function * g8() : Generator<int, ?, ?> {
	yield 1 + 2;
}

// yield has an empty return as default, no return type defined
// XPECT noerrors
function * g9() {
	return;
}

// yield can have an undefined return as default, no return type defined
// XPECT noerrors
function * g10() {
	return undefined;
}

// yield has an empty return as default, shorthand return type
// XPECT noerrors
function * g11() {
	return;
}

// yield can have an undefined return as default, shorthand return type
// XPECT noerrors
function * g12() {
	return undefined;
}

// yield can have an undefined return as default, explitly no return type 1
// XPECT noerrors
function * g13() : Generator<?, ?, ?> {
}

// yield can have an undefined return as default, explitly no return type 2
// XPECT noerrors
function * g14() : Generator<?, ?, ?> {
	return 1;
}

// yield can have an undefined return as default, explitly no return type 3
// XPECT noerrors
function * g15() : Generator<?, ?, ?> {
	return undefined;
}

// yield can have an explit return type
// XPECT noerrors
function * g16() : Generator<?, int, ?> {
	return 0;
}

// yield can have an explit, generic return type
// XPECT noerrors
function * <T>g17(t : T) : Generator<?, T, ?> {
	return t;
}

// The given return type void evaluates to Generator<undefined, undefined, any>
// XPECT noerrors
function * g18() : void {
	return undefined;
}

// The given return type void evaluates to Generator<undefined, undefined, any>
// XPECT noerrors
function * g19() : Generator<undefined,undefined,undefined> {
	return;
}

// err
// The given return type void evaluates to Generator<undefined, undefined, any>
// XPECT errors --> "int is not a subtype of undefined." at "1"
function * g19b() : Generator<undefined,undefined,undefined> {
	return 1;
}

// restricted generator
// XPECT noerrors
function * g20() : Generator<undefined, undefined, undefined> {}
let g20o = g20();

// call next ok
// XPECT noerrors
g20o.next();

// call next ok
// XPECT noerrors
g20o.next(undefined);

// err
// call next arg not allowed
// XPECT errors --> "int is not a subtype of undefined." at "next("1")"
g20o.next("1");

// warn
// return type of next value is undefined
// XPECT warnings
let g20on = g20o.next().value;
g20on;

// err
// throw expects an argument
// XPECT errors
g20o.throw();

// throw expects any argument
// XPECT noerrors
g20o.throw("e");

// call return ok
// XPECT noerrors
g20o.return();

// call return with undefined
// XPECT noerrors
g20o.return(undefined);

// err
// call return arg not allowed
// XPECT errors
g20o.return("1");

// warn
// return type of return value is undefined
// XPECT warnings
let g20or = g20o.return().value;
g20or;


// full feature generator
// XPECT noerrors
function * g21() : Generator<int, string, boolean> {}
let g21o = g21();

// call next ok
// XPECT noerrors
g21o.next();

// call next ok
// XPECT noerrors
g21o.next(undefined);

// call next arg not allowed
// XPECT noerrors
g21o.next(true);

// return type of next value
// XPECT noerrors
let g21on = g21o.next().value;
g21on;

// call return ok
// XPECT noerrors
g21o.return();

// call return with undefined
// XPECT noerrors
g21o.return(undefined);

// call return arg not allowed
// XPECT noerrors
g21o.return(false);

// call return ok
// XPECT noerrors
let g21or = g21o.return().value;
g21or;


interface I {}
interface II extends I {}

function * g30() : Generator<int, string, I> {
	yield 0;
	return "";   
}
// the type TNext of the nested generator function can be a supertype
// XPECT noerrors
function * g31() : Generator<int, string, II> {
	yield * g30();
	return "";   
}

// XPECT noerrors
function * g32() : Generator<II, string, boolean> {
	yield null;
	return "";   
}
// the type TYield of the nested generator function can be a subtype
// XPECT noerrors
function * g33() : Generator<I, string, boolean> {
	yield * g32();
	return "";   
}

// return without expression is ok in shorthand form
// XPECT noerrors
function * g40() : int {
	return;
}

// return with expression is ok in shorthand form
// XPECT noerrors
function * g41() : int {
	return 1;
}

// return without expression is ok when void
// XPECT noerrors
function * g42() : void {
	yield ;
	return;
}

// err
// return with expression is not ok when void
// XPECT errors
function * g43() : void {
	yield ;
	return 1;
}

// return without expression is ok in shorthand form
// XPECT noerrors
let g50 = function * () : int {
	return;
}
g50;

// return with expression is ok in shorthand form
// XPECT noerrors
let g51 = function * () : int {
	return 1;
}
g51;

// return without expression is ok when void
// XPECT noerrors
let g52 = function * () : void {
	yield ;
	return;
}
g52;

// err
// return with expression is not ok when void
// XPECT errors
let g53 = function * () : void {
	yield ;
	return 1;
}
g53;

// yield has return of type TNext
// XPECT noerrors
let g54 = function * () : Generator<?,?,string>{
	let x : string = yield; 
	x;
}
g54;


