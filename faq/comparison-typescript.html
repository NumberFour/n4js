<!DOCTYPE HTML>
<html>
<head>

  <!-- ************* Meta ************* -->
  <title>N4JS and TypeScript · FAQ · N4JS Language and IDE</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  
  <!-- ************* OpenGraph ************-->
  <meta name="description" content="The N4JS language and its IDE enable high-quality JavaScript development for large Node.js projects.">
  
  <meta property="og:site_name" content="N4JS"/>
  <meta property="og:title" content="N4JS Language and IDE"/>
  <meta property="og:url" content="https://numberfour.github.io/n4js"/>
  <meta property="og:description" content="The N4JS language and its IDE enable high-quality JavaScript development for large Node.js projects."/>
  <meta property="og:image" content="../imgs/n4js.png">
  
  <!-- ************* Favicon ************-->
  <link rel="icon" href="../imgs/favicon.ico" />
  <link rel="icon" type="image/png" href="../imgs/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../imgs/favicon-16x16.png" sizes="16x16" />
  <!-- ************* Styles ************* -->
  <link type="text/css" rel="stylesheet" href="//fast.fonts.net/cssapi/20974f8a-0939-4574-aef9-681eda2faca8.css"/>
  <link rel="stylesheet" type="text/css" href="../styles/styles.min.css">


  <!-- ****************** Scripts ****************** -->
  <script type="text/javascript" src="../scripts/scripts-legacy.js"></script>
</head>

<body>
  <header class="Grid">
    <div class="Cell Cell--4-12">
      <a href="../"><img src="../imgs/n4js-logo.png" alt="N4JS Language and IDE"></a>
    </div>

    <div class="Cell Cell--8-12">
      <nav>
         <a href="../#getting-started">Download</a> ·
         <a href="../features">Features</a> ·
         <a href="../documentation">Documentation</a> ·
         <a href="../faq" class="is-active">FAQ</a>
      </nav>
    </div>
  </header>
  <div class="Main">
    <nav class="Nav--top">
      <h2>FAQ</h2>
      <ul>
          <li><a href="../faq" >FAQ</a></li>
          <li><a href="comparison-java.html" >N4JS and Java</a></li>
          <li><a href="comparison-typescript.html" class="is-active">N4JS and Typescript</a></li>
      </ul>
    </nav>
    <article class="Article--noGrid">

<h1>N4JS and TypeScript</h1>

<p class="Introduction">
N4JS and TypeScript are both supersets of ECMAScript. They both introduce type annotations and a static type checker. In their relation to JavaScript, however, they follow different approaches.
</p>

<div class="Image Image"><img src="fig/ts_n4js.svg" /></div>

<p>
TypeScript's goal is to make ECMAScript type safe without breaking existing ECMAScript code. Its type system is optional and the TypeScript transpiler aims to accept plain ECMAScript where possible.
</p>
<p>
N4JS is a superset of ECMAScript in terms of features and syntax but it does not try to be compatible with ECMAScript at all cost. A useful way to explain N4JS is to consider ECMAScript a starting point followed by the addition of Java's strict and rigorous type system, then making this amalgamation as flexible as possible. The resulting state of N4JS is that it fulfils the expectations of a JavaScript developer without compromising the sound type system. 
</p>

<p>This comparison will talk about the <a href="#differences">differences</a> and <a href="#similarities">similarities</a> between N4JS and TypeScript.</p>
<!-- ======================================================================= -->
<h2 id="differences">Differences</h2>
<!-- ======================================================================= -->
<p>
In many cases, TypeScript's design prioritizes the transition from ECMAScript to TypeScript
over type safety. N4JS was designed with this ease of transition in mind but type safety has a higher
priority than ease of transition.
</p>

<h3>Any</h3>

<p>
Both languages introduce a type called <code>any</code>. Whenever an explicit type declaration is missing and no type can be inferred by the system, the type <code>any</code> is used. The precise meaning of <code>any</code> is probably the most important difference between N4JS and TypeScript. Simply put:
</p>

<p style="margin-left:2em;">
<b>In N4JS you can do <i>nothing</i> with <code>any</code>, in TypeScript you can do anything.</b>
</p>

<p>
The following example illustrates the difference:
</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">function f(p: any) {
    p.foo(); // error in N4JS, no error in TypeScript
}
</pre></div>

<p>
N4JS will issue an error "Couldn't resolve reference to IdentifiableElement 'foo'." because in N4JS, the type <code>any</code> has no properties.
</p>
<p>
Furthermore, in N4JS <code>any</code> is the top type: every type is a subtype of <code>any</code>. In TypeScript it is treated as a bottom type similar to <code>undefined</code> (or <code>null</code>): <code>any</code> is a subtype of every other type. The effect of these different semantics is shown in the following example:
</p>
<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">function bar(p: string) {
    p.charAt(0);
}

var s: string = "Hello";
var x: any = 42;

bar(s);
bar(x); // error in N4JS, no error in TypeScript
</pre></div>

<p>
Of course, you would get an error at runtime: "TypeError: p.charAt is not a function".
</p>
<p>
The different interpretations of <code>any</code> reflect the different approaches visualized in the figure at the beginning. <code>any</code> in TypeScript is JavaScript in its purest form: access anything, assign to everything. <code>any</code> in N4JS is even more rigorous than type <code>Object</code> in Java: access nothing, assign to nothing (except <code>any</code> itself).
<!--
It also illustrates how both languages are moving closer to each other: The better the type inferencer is and the more alternative concepts are provided, the less often any is to be used. With the introduction of union types for instance, the usage of any has been reduced in TypeScript and N4JS. Another example is "this" type, introduced with TypeScript 1.8 and also available in N4JS; it also makes some usages of any expandable.
-->
</p>

<p>Note: N4JS allows developers to use types in a dynamic way by using the "<code>+</code>" type modifier. This so-called <em>dynamic type modifier</em> allows for accessing arbitrary properties even when they are not known to the type system. The following example shows the effect:
</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">function f(p: any, d: any+) {
    p.foo(); // error in N4JS
    d.foo(); // no error in N4JS, as d is "dynamic"
}
</pre></div>

<p>
While <code>any+</code> resembles TypeScript's behavior of <code>any</code>, it is still more restrictive: <code>any+</code> will never be used as a default, it has to be declared explicitly. A value of type <code>any+</code> still cannot be assigned to variables of other types except <code>any</code>.
</p>

<table class="Table Table--verticalLines Table--horizontalLines">
<tr><td colspan="2"></td><th>access anything</th><th>assign to everything</th><th>used as default</th></tr>
<tr><td colspan="5"></td></tr>
<tr><th rowspan="2">N4JS</th><th>any</th><td>&#x2715;</td><td>&#x2715;</td><td>&bull;</td></tr>
<tr><th>any+</th><td>&#x2713;</td><td>&#x2715;</td><td></td></tr>
<tr><td colspan="5"></td></tr>
<tr><th>TypeScript</th><th>any</th><td>&#x2713;</td><td>&#x2713;</td><td>&bull;</td></tr>
</table>
<!-- cross would be 2715 -->


<h3>Type Errors Are Show Stoppers in N4JS</h3>
<p>
N4JS has two general levels of issues reported by the compiler: <em>warning</em> and <em>error</em>.
Serious issues like type errors are treated as errors in N4JS and all errors will prevent
the transpiler to emit any JavaScript code in order to avoid (as far as possible) producing
code that can break at runtime.
For TypeScript, on the other hand, one main goal is never to get in the way of the developer.
TypeScript's transpiler will thus produce JavaScript output code even in the case of compile errors.
Given the example from the beginning:
</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">var str = 'Hello';
str = 42;  // both N4JS and TypeScript show an error here
str.charAt(2);
</pre></div>

<p>
The N4JS transpiler will reject the compilation of this code while TypeScript will create a JavaScript output file that breaks at runtime in the last line.
</p>


<h3>Use-Site Variance vs. Assumed Co-Variance</h3>
<p>One of the tricky subtleties of generics is co- and contra-variance. Let's have a look at the hello-world example for generics, a simplified list that can hold only a single element:
</p>
<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">class List&lt;T&gt; {
    read(): T;
    write(T);
}
</pre></div>

<p>
Furthermore, we assume two types <code>A</code> and <code>B</code> with
</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">class A {}
class B extends A { foo() {} }
let a: A = new A(), b: B = new B();
let la: List&lt;A&gt;(), lb: List&lt;B&gt;;
</pre></div>

<p>
That is, <code>B</code> is a subtype of <code>A</code> (it doesn't matter whether we use nominal or structural subtyping). Now for the interesting question; when <code>B</code> is a subtype of <code>A</code>, is <code>List&lt;B&gt;</code> a subtype of <code>List&lt;A&gt;</code>? That is, is it possible to use an instance of <code>List&lt;B&gt;</code> wherever an instance of <code>List&lt;A&gt;</code> is expected? If this were true, <code>List&lt;T&gt;</code> would be co-variant. If the opposite were true, that is, <code>List&lt;A&gt;</code> a subtype of <code>List&lt;B&gt;</code>, then we would say <code>List&lt;T&gt;</code> is contra-variant. If both conclusions are wrong then <code>List&lt;T&gt;</code> is invariant.
</p>

<p>
Now, let's look at the following assignments:
</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">la = lb; // works in TypeScript, N4JS issues an error
lb = la; // both TypeScript and N4JS issue an error
</pre></div>

<p>
Do these assignments work? N4JS and TypeScript will actually give you different answers:
In N4JS, both assignments are rejected. TypeScript, on the other hand, allows the first
assignment but rejects the second. It assumes that when <code>B</code> is a subtype of <code>A</code>, then
<code>List&lt;B&gt;</code> is a subtype of <code>List&lt;B&gt;</code>. TypeScript makes the assumption that generics
are always co-variant.
</p>

<p>
Since it is not obvious why both assignments are rejected by N4JS, let's have a look what happens here:
</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">la = new List&lt;A&gt;(); la.write(a); lb = la; lb.read().foo();
lb = new List&lt;B&gt;(); la = lb; la.write(a); lb.read().foo();
</pre></div>
<p>
In the first line, we create a new list of <code>A</code> and add an a. After assigning <code>lb</code> to <code>la</code>, we have a list of <code>B</code> but it actually contains an <code>A</code>. When we try to call <code>foo()</code> on the object returned (from which we think it is a <code>B</code>), we have a problem!
In the second line, the issue is similar. We create a list of <code>B</code> and instead of adding a <code>B</code>, we first assign <code>lb</code> to <code>la</code> then add an <code>A</code> to the list that says that it accepts <code>A</code>s. It does! But since the list actually is a list of <code>B</code>, we have trouble accessing the (very same) list via <code>lb</code> -- we assume it contains <code>B</code>s, and again we have a problem when calling <code>foo()</code>.
</p>
<p>
This is the case because <code>List&lt;T&gt;</code> is invariant and, in practice, this is very inconvenient. It would be ok to use <code>lb</code> instead of <code>la</code>, assuming we only want to read from the list. On the other hand, if we only want to write to the list then we could use <code>la</code> instead of <code>lb</code> since adding <code>B</code>s to a list expecting <code>A</code> does not do any harm.
</p>
<p>
There are different solutions to the same problem. N4JS follows Java and uses <b>use-site variance</b>. Meaning when the list is used, we can define whether we want to read or write from it. This can be done by using so-called 'wildcards' and constraints when parameterizing the list, for example:
</p>
<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">function copy(readOnlyList: List&lt;? extends A&gt;, writeOnlyList: List&lt;? super A&gt;) {
    writeOnlyList.write( readOnlyList.read );
}
</pre></div>

<p>
Reading (from a list) is much more often used then writing, practically speaking. And in this case, TypeScript's covariant assumption causes no problems. When writing, however, it can cause the above issue.
</p>

<p>
For more information on generics, please refer to the <a href="../features/generics.html">generics feature page</a>.
</p>


<!-- ======================================================================= -->
<h2 id="similarities">Similarities</h2>
<!-- ======================================================================= -->

<h3>Explicit and Implicit typing</h3>
<p>
In both languages, types can be defined either implicitly or explicitly via a type annotation. In the former case, the type is to be inferred by the type system. A simple example is the assignment of a value to a newly declared variable:
</p>
<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">let foo = "Hello";
</pre></div>

<p>
Both languages would infer the type of <code>foo</code> to <code>string</code>. In both languages, the following assignment would lead to an error:

</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">foo = 42; // error
</pre></div>
<p>
N4JS would issue "int is not a subtype of string.", TypeScript "Type 'number' is not assignable to type 'string'".
</p>


<h3>Structural Types</h3>
<p>
N4JS and TypeScript both support <a href="../features/nominal-and-structural-typing.html">structural types</a>. This allows for managing relations between types without the need for excessive declarations. Instead of explicitly defining type relations via "extends" or "implements", the type system compares the properties of two types. If one type has all the properties of another type, it is considered to be a subtype.
</p>
<p>
As a significant difference between the two languages, N4JS also supports <em>nominal types</em> and nominal typing <em>is the default</em>. Thus, structural types have to be explicitly annotated as being structural using the <code>~</code> or <code>~~</code> type constructors.
</p>

<div class="Comparison">
  <div class="Comparison-left">
<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">  export public interface ~Point {
      x : number;
      y : number;
  }
  export public interface ~Point3D {
      x : number;
      y : number;
      z : number;
  }
  var p: Point = { x: 0, y: 10, };
  var p3d: Point3D = { x: 0, y: 10, z: 20 }

  p = p3d;
  p3d = p; // error
</pre><div class="Example-caption">N4JS</div></div>
  </div>
  <div class="Comparison-right">
<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">  interface Point {
      x : number;
      y : number;
  }
  interface Point3D {
      x : number;
      y : number;
      z : number;
  }
  var p: Point = { x: 0, y: 10, };
  var p3d: Point3D = { x: 0, y: 10, z: 20 }

  p = p3d;
  p3d = p; // error
</pre><div class="Example-caption">TypeScript</div></div>
  </div>
</div>

<p>
Note that N4JS is using different default for access modifiers, e.g. <code>public</code> is not the default. For that reason, the interfaces have to be marked as public (and exported).
</p>
<p>
In both languages, an error will be issued on the last line:
"Point is not a structural subtype of Point3D: missing field z." (N4JS) and "Type 'Point' is not assignable to Type 'Point3D'. Property 'z' is missing in type 'Point'." (TypeScript), respectively.
</p>
<p>
The difference between structural and nominal typeing is described in further detail <a href="../features/nominal-and-structural-typing.html">here</a>.
</p>

<h3>Using Existing JavaScript Libraries</h3>
<p>
An important benefit of being an ECMAScript superset is enabling developers to use existing JavaScript libraries. N4JS and TypeScript support type definitions for existing code. For TypeScript there is a great project called <a href="http://definitelytyped.org/">DefinitelyTyped</a> where these type definitions are collected. For N4JS, a similar <a href="https://github.com/NumberFour/n4jsd">GitHub project exists</a>, but it contains very few definitions at the moment. Contributions are welcome for both projects.
</p>
<p>It is also possible in both languages to use existing code, in particular Common.js modules, without type definitions. The N4JS IDE <a href="../features/nodejs-support.html">integrates support for NPM</a> so that these modules, even without a type definition, can seamlessly be used in N4JS.
</p>



    </article>

  </div>


  <footer class="Grid">
    <div class="Cell Cell--12-12">
      <a href="http://www.numberfour.eu" target="_blank">NumberFour AG</a> · <a href="https://twitter.com/n4jsdev" target="_blank">Twitter</a>

      <a href="../#getting-started" class="Link--action">Get the N4JS IDE now!</a>
    </div>
  </footer>
  <script>
    dp.SyntaxHighlighter.HighlightAll('code');
  </script>

</body>
</html>
